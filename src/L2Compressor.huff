#include "./Errors.huff"

#define constant ADDR_BYTES_STORAGE = 0x00
#define constant FMS = 0xa0
#define constant NESTED_READ_FLAG_RETURN_MSLOT = 0x80

#define constant FLAG_READ_BYTES32_2_BYTES = 0x27
#define constant FLAG_READ_ADDRESS_2_BYTES = 0x23

#define constant READ_BYTES32_X_BYTES_FLAG_OFFSET = 0x25 // (FLAG_READ_BYTES32_2_BYTES - 2) since it starts at 2 bytes
#define constant READ_ADDRESS_X_BYTES_FLAG_OFFSET = 0x21 // (FLAG_READ_ADDRESS_2_BYTES - 2) since it starts at 2 bytes

#define constant BYTES32_SMV = 0x80
#define constant ADDRESS_SMV = 0x01

// #define macro MAIN() = takes (0) returns (0) {
//   0x00                 // [rindex]
//   [FMS]  // [windex, rindex]

//   0x01                 // [flag, windex, rindex]
//   READ_FLAG()          // [windex, rindex]
// }

#define macro ADDRESSES_NUM() = takes (0) returns (1) {
  [ADDR_BYTES_STORAGE] sload // [packed]
  0x80 shr                 // [num]

  // output stack: [num]
}

#define macro PULL_ADDRESS() = takes(0) returns (1) {
  [ADDR_BYTES_STORAGE] sload // [packed]
  dup1                       // [packed, packed]
  0x80 shr                   // [num, packed]

  0x01 add                   // [num + 1, packed]
  swap1                      // [packed, num + 1]

  // Mask packed (only want lower 128 bits)
  0xffffffffffffffffffffffffffffffff and

  dup2                       // [num + 1, packed, num + 1]
  0x80 shl                   // [num + 1 << 0x80, packed, num + 1]
  or                         // [nextpacked, num + 1]

  [ADDR_BYTES_STORAGE] sstore // [num + 1]

  // output stack: [num + 1]
}

#define macro BYTES32_STORAGE_POINTER() = takes (1) returns (1) {
  // input stack: [index]
  0x80 shl
  // output stack: [index << 0x80]
}

#define macro ADDRESS_STORAGE_POINTER() = takes (1) returns (1) {
  // input stack: [index]
  0x01 add
  // output stack: [index + 1]
}

#define macro BYTES32_NUM() = takes (0) returns (1) {
  [ADDR_BYTES_STORAGE] sload             // [packed]
  0xffffffffffffffffffffffffffffffff and // [num]

  // output stack: [num]
}

#define macro PULL_BYTES32() = takes(0) returns (1) {
  [ADDR_BYTES_STORAGE] sload             // [packed]
  dup1                                   // [packed, packed]
  0xffffffffffffffffffffffffffffffff and // [num, packed]

  0x01 add                               // [num + 1, packed]
  swap1                                  // [packed, num + 1]

  0xffffffffffffffffffffffffffffffff00000000000000000000000000000000 and // [packed, num + 1]

  dup2                                   // [num + 1, packed, num + 1]
  or                                     // [nextpacked, num + 1]

  [ADDR_BYTES_STORAGE] sstore            // [num + 1]

  // output stack: [num + 1]
}

#define jumptable__packed FLAG_TABLE {
  FLAG_READ_BYTES32_0_BYTES  // 0x00
  FLAG_READ_BYTES32_1_BYTES  // 0x01
  FLAG_READ_BYTES32_2_BYTES  // 0x02
  FLAG_READ_BYTES32_3_BYTES  // 0x03
  FLAG_READ_BYTES32_4_BYTES  // 0x04
  FLAG_READ_BYTES32_5_BYTES  // 0x05
  FLAG_READ_BYTES32_6_BYTES  // 0x06
  FLAG_READ_BYTES32_7_BYTES  // 0x07
  FLAG_READ_BYTES32_8_BYTES  // 0x08
  FLAG_READ_BYTES32_9_BYTES  // 0x09
  FLAG_READ_BYTES32_10_BYTES // 0x0a
  FLAG_READ_BYTES32_11_BYTES // 0x0b
  FLAG_READ_BYTES32_12_BYTES // 0x0c
  FLAG_READ_BYTES32_13_BYTES // 0x0d
  FLAG_READ_BYTES32_14_BYTES // 0x0e
  FLAG_READ_BYTES32_15_BYTES // 0x0f
  FLAG_READ_BYTES32_16_BYTES // 0x10
  FLAG_READ_BYTES32_17_BYTES // 0x11
  FLAG_READ_BYTES32_18_BYTES // 0x12
  FLAG_READ_BYTES32_19_BYTES // 0x13
  FLAG_READ_BYTES32_20_BYTES // 0x14
  FLAG_READ_BYTES32_21_BYTES // 0x15
  FLAG_READ_BYTES32_22_BYTES // 0x16
  FLAG_READ_BYTES32_23_BYTES // 0x17
  FLAG_READ_BYTES32_24_BYTES // 0x18
  FLAG_READ_BYTES32_25_BYTES // 0x19
  FLAG_READ_BYTES32_26_BYTES // 0x1a
  FLAG_READ_BYTES32_27_BYTES // 0x1b
  FLAG_READ_BYTES32_28_BYTES // 0x1c
  FLAG_READ_BYTES32_29_BYTES // 0x1d
  FLAG_READ_BYTES32_30_BYTES // 0x1e
  FLAG_READ_BYTES32_31_BYTES // 0x1f
  FLAG_READ_BYTES32_32_BYTES // 0x20
  JUMP_SAVE_ADDRESS          // 0x21
  JUMP_SAVE_BYTES32          // 0x22
  JUMP_READ_ADDRESS_2        // 0x23
  JUMP_READ_ADDRESS_3        // 0x24
  JUMP_READ_ADDRESS_4        // 0x25
  JUMP_READ_ADDRESS_5        // 0x26
  JUMP_READ_BYTES32_2        // 0x27
  JUMP_READ_BYTES32_3        // 0x28
  JUMP_READ_BYTES32_4        // 0x29
  JUMP_READ_BYTES32_5        // 0x2a
  JUMP_READ_N_BYTES          // 0x2b
  JUMP_READ_POWER_OF_2       // 0x2c
  FLAG_ABI_0_PARAM           // 0x2d
  FLAG_ABI_1_PARAM           // 0x2e
  FLAG_ABI_2_PARAMS          // 0x2f
  FLAG_ABI_3_PARAMS          // 0x20
  FLAG_ABI_4_PARAMS          // 0x31
  FLAG_ABI_5_PARAMS          // 0x32
  FLAG_ABI_6_PARAMS          // 0x33
}

#define constant HIGHEST_FLAG = 0x32

#define macro READ_FLAG() = takes (2) returns (2) {
  nested_read_flag_start:
  // input stack: [windex, rindex]

  dup2          // [rindex, windex, rindex]
  calldataload  // [cdata[rindex], windex, rindex]
  0x00 byte     // [flag, windex, rindex]

  swap2         // [rindex, windex, flag]
  0x01 add      // [rindex + 1, windex, flag]
  swap2         // [flag, windex, rindex + 1]

  dup1                        // [flag, flag, windex, rindex + 1]
  [HIGHEST_FLAG] lt           // [HIGHEST_FLAG < flag, flag, windex, rindex + 1]
  default jumpi               // [flag, windex, rindex + 1]

  __tablesize(FLAG_TABLE)     // [table_size, flag, windex, rindex + 1]
  __tablestart(FLAG_TABLE)    // [table_start, table_size, flag, windex, rindex + 1]
  0x00                        // [0x00, table_start, table_size, flag, windex, rindex + 1]
  codecopy                    // [flag, windex, rindex + 1]

  dup1                        // [flag, flag, windex, rindex + 1]
  0x01 shl                    // [flag << 0x01, flag, windex, rindex + 1]
  mload                       // [word, flag, windex, rindex + 1]
  0xf0 shr                    // [word >> 0xf0, flag, windex, rindex + 1]
  jump                        // [flag, windex, rindex + 1]

  FLAG_READ_BYTES32_0_BYTES:
    READ_BYTES32_EMPTY()     // [windex, rindex]
    end jump
  FLAG_READ_BYTES32_1_BYTES:
    READ_BYTES32(0xf8, 0x01) // [windex, rindex]
    end jump
  FLAG_READ_BYTES32_2_BYTES:
    READ_BYTES32(0xf0, 0x02) // [windex, rindex]
    end jump
  FLAG_READ_BYTES32_3_BYTES:
    READ_BYTES32(0xe8, 0x03) // [windex, rindex]
    end jump
  FLAG_READ_BYTES32_4_BYTES:
    READ_BYTES32(0xe0, 0x04) // [windex, rindex]
    end jump
  FLAG_READ_BYTES32_5_BYTES:
    READ_BYTES32(0xd8, 0x05) // [windex, rindex]
    end jump
  FLAG_READ_BYTES32_6_BYTES:
    READ_BYTES32(0xd0, 0x06) // [windex, rindex]
    end jump
  FLAG_READ_BYTES32_7_BYTES:
    READ_BYTES32(0xc8, 0x07) // [windex, rindex]
    end jump
  FLAG_READ_BYTES32_8_BYTES:
    READ_BYTES32(0xc0, 0x08) // [windex, rindex]
    end jump
  FLAG_READ_BYTES32_9_BYTES:
    READ_BYTES32(0xb8, 0x09) // [windex, rindex]
    end jump
  FLAG_READ_BYTES32_10_BYTES:
    READ_BYTES32(0xb0, 0x0a) // [windex, rindex]
    end jump
  FLAG_READ_BYTES32_11_BYTES:
    READ_BYTES32(0xa8, 0x0b) // [windex, rindex]
    end jump
  FLAG_READ_BYTES32_12_BYTES:
    READ_BYTES32(0xa0, 0x0c) // [windex, rindex]
    end jump
  FLAG_READ_BYTES32_13_BYTES:
    READ_BYTES32(0x98, 0x0d) // [windex, rindex]
    end jump
  FLAG_READ_BYTES32_14_BYTES:
    READ_BYTES32(0x90, 0x0e) // [windex, rindex]
    end jump
  FLAG_READ_BYTES32_15_BYTES:
    READ_BYTES32(0x88, 0x0f) // [windex, rindex]
    end jump
  FLAG_READ_BYTES32_16_BYTES:
    READ_BYTES32(0x80, 0x10) // [windex, rindex]
    end jump
  FLAG_READ_BYTES32_17_BYTES:
    READ_BYTES32(0x78, 0x11) // [windex, rindex]
    end jump
  FLAG_READ_BYTES32_18_BYTES:
    READ_BYTES32(0x70, 0x12) // [windex, rindex]
    end jump
  FLAG_READ_BYTES32_19_BYTES:
    READ_BYTES32(0x68, 0x13) // [windex, rindex]
    end jump
  FLAG_READ_BYTES32_20_BYTES:
    READ_BYTES32(0x60, 0x14) // [windex, rindex]
    end jump
  FLAG_READ_BYTES32_21_BYTES:
    READ_BYTES32(0x58, 0x15) // [windex, rindex]
    end jump
  FLAG_READ_BYTES32_22_BYTES:
    READ_BYTES32(0x50, 0x16) // [windex, rindex]
    end jump
  FLAG_READ_BYTES32_23_BYTES:
    READ_BYTES32(0x48, 0x17) // [windex, rindex]
    end jump
  FLAG_READ_BYTES32_24_BYTES:
    READ_BYTES32(0x40, 0x18) // [windex, rindex]
    end jump
  FLAG_READ_BYTES32_25_BYTES:
    READ_BYTES32(0x38, 0x19) // [windex, rindex]
    end jump
  FLAG_READ_BYTES32_26_BYTES:
    READ_BYTES32(0x30, 0x1a) // [windex, rindex]
    end jump
  FLAG_READ_BYTES32_27_BYTES:
    READ_BYTES32(0x28, 0x1b) // [windex, rindex]
    end jump
  FLAG_READ_BYTES32_28_BYTES:
    READ_BYTES32(0x20, 0x1c) // [windex, rindex]
    end jump
  FLAG_READ_BYTES32_29_BYTES:
    READ_BYTES32(0x18, 0x1d) // [windex, rindex]
    end jump
  FLAG_READ_BYTES32_30_BYTES:
    READ_BYTES32(0x10, 0x1e) // [windex, rindex]
    end jump
  FLAG_READ_BYTES32_31_BYTES:
    READ_BYTES32(0x08, 0x1f) // [windex, rindex]
    end jump
  FLAG_READ_BYTES32_32_BYTES:
    READ_BYTES32_WORD()      // [windex, rindex]
    end jump

  JUMP_SAVE_ADDRESS:
    SAVE_ADDRESS() // [windex, rindex]
    end jump

  JUMP_SAVE_BYTES32:
    SAVE_BYTES32() // [windex, rindex]
    end jump

  JUMP_READ_ADDRESS_2:
  JUMP_READ_ADDRESS_3:
  JUMP_READ_ADDRESS_4:
  JUMP_READ_ADDRESS_5:
    READ_ADDRESS_STORAGE()      // [windex, rindex]
    end jump

  JUMP_READ_BYTES32_2:
  JUMP_READ_BYTES32_3:
  JUMP_READ_BYTES32_4:
  JUMP_READ_BYTES32_5:
    READ_BYTES32_STORAGE()      // [windex, rindex]
    end jump

  JUMP_READ_N_BYTES:
    READ_N_BYTES(nested_read_flag_start) // [windex, rindex]
    end jump

  JUMP_READ_POWER_OF_2:
    READ_POWER_OF_2()   // [windex, rindex]
    end jump

  FLAG_ABI_0_PARAM:
    READ_ABI(nested_read_flag_start, 0x00) // [windex, rindex]
    end jump
  FLAG_ABI_1_PARAM:
    READ_ABI(nested_read_flag_start, 0x01) // [windex, rindex]
    end jump
  FLAG_ABI_2_PARAMS:
    READ_ABI(nested_read_flag_start, 0x02) // [windex, rindex]
    end jump
  FLAG_ABI_3_PARAMS:
    READ_ABI(nested_read_flag_start, 0x03) // [windex, rindex]
    end jump
  FLAG_ABI_4_PARAMS:
    READ_ABI(nested_read_flag_start, 0x04) // [windex, rindex]
    end jump
  FLAG_ABI_5_PARAMS:
    READ_ABI(nested_read_flag_start, 0x05) // [windex, rindex]
    end jump
  FLAG_ABI_6_PARAMS:
    READ_ABI(nested_read_flag_start, 0x06) // [windex, rindex]
    end jump

  default:
    // The default just pushes the flag as a byte (padded to 32 bytes)
    // notice that we start at 0x01 since 0x00 can be pushed with the flag 0x00
    [HIGHEST_FLAG]  // [HIGHEST_FLAG, flag, windex, rindex]
    swap1 sub       // [flag - HIGHEST_FLAG, windex, rindex]
    dup2            // [windex, flag - HIGHEST_FLAG, windex, rindex]
    mstore          // [windex, rindex]
    0x20 add        // [windex + 0x20, rindex]

  end:

  // If the NESTED memory slot is not 0, then we need to jump there
  // but each "return" only takes 2 bytes, so we need to only jump to
  // to the last 2 bytes. Notice that this limits nested calls to a depth
  // of 16 only.

  [NESTED_READ_FLAG_RETURN_MSLOT] mload  // [nrfr, windex, rindex]
  0xffff and                             // [nrfr & 0xffff, windex, rindex]
  dup1 jumpi                             // [windex, rindex]
}

#define macro PERFORM_NESTED_READ_FLAG(nrfs) = takes(0) returns (0) {
  // input stack: []

  [NESTED_READ_FLAG_RETURN_MSLOT] mload // [nrfr]
  0x10 shl                              // [nrfr << 0x10]
  back or                               // [nrfr << 0x10 | back]
  [NESTED_READ_FLAG_RETURN_MSLOT]       // [nrfr, new_nrfr]
  mstore                                // []

  <nrfs> jump // []

  back:

  // Clear the last callback pointer
  [NESTED_READ_FLAG_RETURN_MSLOT] mload  // [nrfr]
  0x10 shr                               // [nrfr >> 0x10]
  [NESTED_READ_FLAG_RETURN_MSLOT] mstore // []
}

#define macro BACKREAD_SINGLE_VALUE() = takes (1) returns (2) {
  // input stack: [windex]

  0x20 swap1 sub // [windex - 0x20]
  dup1           // [windex - 0x20, windex - 0x20]

  mload          // [mem[windex - 0x20], windex - 0x20]

  // output stack: [mem[windex - 0x20], windex - 0x20]
}

#[calldata("0x02f1f2")]
#define test TEST_READ_FLAG_2_BYTES() = {
  0x00  // [rindex]
  [FMS] // [windex, rindex]

  READ_FLAG() // [windex, rindex]

  0x20 [FMS] add eq ASSERT() // [rindex]
  0x03 eq ASSERT()           // []

  [FMS] mload 0xf1f2 eq ASSERT() // []
}

#[calldata("0x1000")]
#define test TEST_READ_FLAG_0_BYTES() = {
  0x02  // [rindex]
  [FMS] // [windex, rindex]

  // Store something
  0x10 [FMS] mstore

  READ_FLAG() // [windex, rindex]

  0x20 [FMS] add eq ASSERT() // [rindex]
  0x03 eq ASSERT()           // []

  [FMS] mload 0x00 eq ASSERT() // []
}

#define test TEST_NUMS() = {
  ADDRESSES_NUM()  // [num]
  0x00 eq ASSERT() // []

  PULL_ADDRESS()   // [nnum]
  0x01 eq ASSERT() // []

  ADDRESSES_NUM()  // [num]
  0x01 eq ASSERT() // []

  PULL_ADDRESS()   // [nnum]
  0x02 eq ASSERT() // []

  ADDRESSES_NUM()  // [num]
  0x02 eq ASSERT() // []

  PULL_BYTES32()   // [nnum]
  0x01 eq ASSERT() // []

  BYTES32_NUM()    // [num]
  0x01 eq ASSERT() // []

  ADDRESSES_NUM()  // [num]
  0x02 eq ASSERT() // []

  PULL_ADDRESS()   // [nnum]
  0x03 eq ASSERT() // []

  BYTES32_NUM()   // [nnum]
  0x01 eq ASSERT() // []

  PULL_BYTES32()   // [nnum]
  0x02 eq ASSERT() // []

  BYTES32_NUM()    // [num]
  0x02 eq ASSERT() // []

  ADDRESSES_NUM()  // [num]
  0x03 eq ASSERT() // []
}

#define macro READ_TRANSACTION() = takes (2) returns (2) {
  // input stack: [windex, rindex]

  // The first byte gives us information about what the transaction contains

  dup2          // [rindex, windex, rindex]
  calldataload  // [cdata[rindex], windex, rindex]
  0x00 byte     // [tflag, windex, rindex]
  swap2         // [rindex, windex, tflag]
  0x01 add      // [rindex + 1, windex, tflag]
  swap2         // [tflag, windex, rindex + 1]

  // First bit of the flag determines if the transaction uses delegateCall

  dup1          // [tflag, tflag, windex, rindex]
  0x07 shr      // [tflag >> 0x07, tflag, windex, rindex]
  dup3          // [windex, tflag >> 0x07, tflag, windex, rindex]
  mstore        // [tflag, windex, rindex]

  swap1         // [windex, tflag, rindex]
  0x20 add      // [windex + 0x20, tflag, rindex]

  // Second bit of the flag determines if the transaction uses revertOnError

  dup2          // [tflag, windex, tflag, rindex]
  0x06 shr      // [tflag >> 0x06, windex, tflag, rindex]
  0x01 and      // [tflag >> 0x06 & 0x01, windex, tflag, rindex]
  dup3          // [windex, tflag >> 0x06 & 0x01, windex, tflag, rindex]
  mstore        // [windex, tflag, rindex]

  0x20 add      // [windex + 0x20, tflag, rindex]

  // Third bit of the flag determines if the transaction has a defined gasLimit

  dup2                // [tflag, windex, tflag, rindex]
  0x05 shr            // [tflag >> 0x05, windex, tflag, rindex]
  0x01 and            // [has_gas_limit, windex, tflag, rindex]
  has_gas_limit jumpi // [windex, tflag, rindex]

    // The transaction has no gas_limit, we still need to write 0s
    // to the memory and push the write index

    0x00 dup2 mstore // [windex, tflag, rindex]
    0x20 add         // [windex + 0x20, tflag, rindex]

    // Re-arrange the stack so it matches the other branch

    swap1         // [tflag, windex, rindex]
    swap2         // [rindex, windex, tflag]
    swap1         // [windex, rindex, tflag]

    end_gas_Limit_if jump

  has_gas_limit:

    // Read advanced; this should only increase 32 bytes
    // but we don't check that, buyer beware

    swap1         // [tflag, windex, rindex]
    swap2         // [rindex, windex, tflag]
    swap1         // [windex, rindex, tflag]

    READ_FLAG()   // [windex, rindex, tflag]

  end_gas_Limit_if:

  // All transactions must define an address
  // this is simple, as it is just one more flag

  READ_FLAG()

  // 4th bit of the flag determines if the transaction has a defined value

  dup3               // [tflag, windex, rindex, tflag]
  0x04 shr           // [tflag >> 0x04, windex, rindex, tflag]
  0x01 and           // [tflag >> 0x04 & 0x01, windex, rindex, tflag]
  has_value jumpi    // [windex, rindex, tflag]

    // The transaction has no value, we still need to write 0s
    // to the memory and push the write index

    0x00 dup2 mstore   // [windex, rindex, tflag]
    0x20 add           // [windex + 0x20, rindex, tflag]
    end_value_if jump

  has_value:

    // Read advanced; this should only increase 32 bytes
    // but we don't check that, buyer beware

    READ_FLAG()   // [windex, rindex, tflag]
  
  end_value_if:

  // 1st bit determines if the transaction has data

  swap2           // [tflag, rindex, windex]
  0x01 and        // [has_data, rindex, windex]  

  swap1           // [rindex, has_data, windex]
  swap2           // [windex, has_data, rindex]
  swap1           // [has_data, windex, rindex]

  has_data jumpi  // [windex, rindex]
    
    // The transaction has no data, we still need to write 0s
    // both for the pointer and size

    dup1          // [windex, windex, rindex]
    0x20 add      // [windex + 0x20, windex, rindex]
    dup1          // [windex + 0x20, windex + 0x20, windex, rindex]
    swap2         // [windex, windex + 0x20, windex + 0x20, rindex]
    mstore        // [windex + 0x20, rindex]
    0x00          // [0x00, windex + 0x20, rindex]
    dup2          // [windex + 0x20, 0x00, windex + 0x20, rindex]
    mstore        // [windex + 0x20, rindex]
    0x20 add      // [windex + 0x40, rindex]

    end_data_if jump

  has_data:       // [windex, rindex]

    swap1         // [rindex, windex]
    dup2          // [windex, rindex, prev_windex]

    // Leave some room to store the size of the data
    0x20 add      // [windex + 0x20, rindex, prev_windex]

    READ_FLAG()   // [windex, rindex, prev_windex]

    dup3          // [prev_windex, windex, rindex, prev_windex]
    dup2          // [windex, prev_windex, windex, rindex, prev_windex]
    sub           // [(windex - prev_windex), windex, rindex, prev_windex]
    0x20 add      // [size, windex, rindex, prev_windex]

    dup4          // [prev_windex, size, windex, rindex, prev_windex]
    mstore        // [windex, rindex, prev_windex]
    swap2         // [prev_windex, rindex, windex]
    pop           // [rindex, windex]
    swap1         // [windex, rindex]

  end_data_if:
}

#define macro READ_ABI(nrfs, nparams) = takes (3) returns (2) {
  // input stack: [flag, windex, rindex]

  pop            // [windex, rindex]

  // Reserve 32 bytes to store the size, dynamic values
  // use the first 32 bytes to store the size of the value
  0x20           // [0x20, windex, rindex]
  add            // [0x20 + windex, rindex]

  0x04           // [0x04, windex, rindex]
  dup1           // [0x04, 0x04, windex, rindex]
  dup4           // [rindex, 0x04, 0x04, windex, rindex]
  dup4           // [windex, rindex, 0x04, 0x04, windex, rindex]
  calldatacopy   // [0x04, windex, rindex]

  dup2           // [windex, 0x04, windex, rindex]

  swap3          // [rindex, 0x04, windex, windex]
  add            // [rindex + 0x04, windex, windex]

  swap1          // [windex, rindex + 0x04, windex]
  0x04 add       // [windex + 0x04, rindex + 0x04, windex]
  swap1          // [rindex + 0x04, windex + 0x04, windex]

  0x00           // [i, rindex, windex, prev_windex]
  read_param:    // [i, rindex, windex, prev_windex]
    swap2        // [windex, rindex, i, prev_windex]

    PERFORM_NESTED_READ_FLAG(<nrfs>) // [windex, rindex, i, prev_windex]
    BACKREAD_SINGLE_VALUE()          // [val, windex, rindex, i, prev_windex]

    dup2         // [windex, val, windex, rindex, i, prev_windex]
    mstore       // [windex, rindex, i, prev_windex]

    0x20 add     // [windex + 0x20, rindex, i, prev_windex]

    swap2        // [i, rindex, windex + 0x20, prev_windex]

    0x01 add     // [i + 1, rindex, windex, prev_windex]

    dup1         // [i + 1, i + 1, rindex, windex, prev_windex]
    <nparams> lt // [i + 1 < nparams, i + 1, rindex, windex, prev_windex]
    read_param   // [read_param, i + 1 < nparams, i + 1, rindex, windex, prev_windex]
    jumpi        // [i + 1, rindex, windex, prev_windex]

  pop            // [rindex, windex, prev_windex]

  // We need to fill the last 32 bytes with 0x00, dynamic values
  // must be padded to 32 bytes

  dup3           // [prev_windex, rindex, windex, prev_windex]
  dup3           // [windex, prev_windex, rindex, windex, prev_windex]
  
  sub            // [size, rindex, windex, prev_index]
  dup1           // [size, size, rindex, windex, prev_index]

  0x1f and       // [size % 32, size, rindex, windex, prev_index]
  0x20 sub       // [32 - size % 32, size, rindex, windex, prev_index]

  // Zero out the memory, just in case

  0x00          // [0x00, 32 - size % 32, size, rindex, windex, prev_index]
  dup5          // [windex, 0x00, 32 - size % 32, size, rindex, windex, prev_index]
  mstore        // [32 - size % 32, size, rindex, windex, prev_index]

  // Advance the windex by the number of required bytes
  swap1         // [size, 32 - size % 32, rindex, windex, prev_index]
  swap3         // [windex, 32 - size % 32, rindex, size, prev_index]
  add           // [windex, rindex, size, prev_index]

  // Now we need to store the full size of the value
  // luckly windex - prev_index should give us the padded index

  swap2         // [size, rindex, windex, prev_index]
  0x20          // [0x20, size, rindex, windex, prev_index]
  dup5          // [prev_index, size, rindex, windex, prev_index]
  sub           // [(0x20 - prev_index), size, rindex, windex, prev_index]
  mstore        // [rindex, windex, prev_index]

  swap2         // [prev_index, windex, rindex]
  pop           // [windex, rindex]

  // output stack: [windex, rindex]
}

#define macro READ_BYTES32(shift_bits, read_bytes) = takes (3) returns (2) {
  // input stack: [flag, windex, rindex]

  pop            // [windex, rindex]

  0x20           // [0x20, windex, rindex]

  dup3           // [rindex, 0x20, windex, rindex]
  calldataload   // [word, 0x20, windex, rindex]

  // Shift to the right so we only read the first <val> bits
  <shift_bits> shr      // [word >> <val>, 0x20, windex, rindex]

  // Store on windex
  dup3           // [windex, word >> <val>, 0x20, windex, rindex]
  mstore         // [0x20, windex, rindex]

  add            // [windex + 0x20, rindex]

  swap1             // [rindex, windex + 0x20]
  <read_bytes> add  // [rindex + <val>, windex + 0x20]
  swap1             // [windex + 0x20, rindex + <val>]

  // output stack: [0x20 + windex, valB + rindex]
}

#define macro READ_BYTES32_EMPTY() = takes (3) returns (2) {
  // input stack: [flag, windex, rindex]

  pop            // [windex, rindex]

  0x00           // [0x00, windex, rindex]
  dup2           // [windex, 0x00, windex, rindex]
  mstore         // [windex, rindex]

  0x20           // [0x20, windex, rindex]
  add            // [(0x20 + windex), rindex]

  // input stack: [flag, windex, rindex]
}

#define macro READ_BYTES32_WORD() = takes (3) returns (2) {
  // input stack: [flag, windex, rindex]

  pop            // [windex, rindex]

  0x20           // [0x20, windex, rindex]
  dup1           // [0x20, 0x20, windex, rindex]

  dup4           // [rindex, 0x20, 0x20, windex, rindex]
  calldataload   // [word, 0x20, 0x20, windex, rindex]

  // Store on windex
  dup4           // [windex, word >> <val>, 0x20, 0x20, windex, rindex]
  mstore         // [0x20, 0x20, windex, rindex]

  swap3          // [rindex, 0x20, 0x20, windex]
  add            // [rindex + 0x20, 0x20, windex]
  swap2          // [windex, 0x20, rindex + 0x20]
  add            // [windex + 0x20, rindex + 0x20]

  // output stack: [windex + 0x20, rindex + 0x20]
}

#[calldata("0xb2d10eb37ef5838bb835ea71bbd4053daf8de7bd8ecdf638451a2bc966a145a8"), value(0x01)]
#define test TEST_FLAG_READ_BYTES32() = {
  0x01            // [rindex]
  [FMS] 0x40 add  // [windex, rindex]
  0x00            // [flag, windex, rindex]

  READ_BYTES32(0xf0, 0x02)      // [windex, rindex]

  [FMS] 0x60 add eq ASSERT()    // [rindex]
  0x03 eq ASSERT()                            // []

  [FMS] 0x40 add mload 0xd10e eq ASSERT() // []

  0x00  // [rindex]
  [FMS] // [windex, rindex]
  0xff  // [flag, windex, rindex]

  READ_BYTES32(0x00, 0x20) // [windex, rindex]

  [FMS] 0x20 add eq ASSERT()    // [rindex]
  0x20 eq ASSERT()              // []

  [FMS] mload 0xb2d10eb37ef5838bb835ea71bbd4053daf8de7bd8ecdf638451a2bc966a145a8 eq ASSERT() // []

  0x00           // [rindex]
  [FMS] 0x40 add // [windex, rindex]
  0x00           // [flag, windex, rindex]

  READ_BYTES32_WORD() // [windex, rindex]

  [FMS] 0x60 add eq ASSERT()    // [rindex]
  0x20 eq ASSERT()              // []

  [FMS] 0x40 add
  mload 0xb2d10eb37ef5838bb835ea71bbd4053daf8de7bd8ecdf638451a2bc966a145a8 eq ASSERT() // []

  0x15           // [rindex]
  [FMS] 0x10 add // [windex, rindex]
  0xf1           // [flag, windex, rindex]

  READ_BYTES32_EMPTY() // [windex, rindex]

  [FMS] 0x30 add eq ASSERT()    // [rindex]
  0x15 eq ASSERT()              // []

  [FMS] 0x10 add mload 0x00 eq ASSERT() // []
}

#define macro SAVE_ADDRESS() = takes (3) returns (2) {
  // input stack: [flag, windex, rindex]

  pop            // [windex, rindex]

  dup2           // [rindex, windex, rindex]
  calldataload   // [word, windex, rindex]

  // Clean the address before storing it
  // shifting it to the right by 0x60 bits

  0x60 shr       // [addr, windex, rindex]

  dup1           // [addr, addr, windex, rindex]
  dup3           // [windex, addr, addr, windex, rindex]
  mstore         // [addr, windex, rindex]

  PULL_ADDRESS() ADDRESS_STORAGE_POINTER() sstore // [windex, rindex]

  // Add 32 bytes to windex and 20 to rindex
  0x20 add       // [windex + 0x20, rindex]
  swap1          // [rindex, windex + 0x20]
  0x14 add       // [rindex + 0x14, windex + 0x20]
  swap1          // [windex + 0x20, rindex + 0x14]
  
  // output stack: [windex + 0x20, rindex + 0x14]
}

// 0xd10eb37ef5838bb835ea71bbd4053daf8de7bd8e
#[calldata("0xb2d10eb37ef5838bb835ea71bbd4053daf8de7bd8ecdf638451a2bc966a145a8"), value(0x01)]
#define test TEST_SAVE_ADDRESS() = {
  0x01  // [rindex]
  [FMS] // [windex, rindex]

  0x02 // [flag, windex, rindex]

  SAVE_ADDRESS() // [windex, rindex]

  [FMS] 0x20 add eq ASSERT() // [rindex]
  0x15 eq ASSERT()           // []

  // Validate that memory was written correctly

  [FMS] mload  // [mem[0x20]] ()
  0x000000000000000000000000d10eb37ef5838bb835ea71bbd4053daf8de7bd8e
  eq ASSERT()  // []

  // Validate that the written address is correct
  0x02 sload // [addr]
  0x000000000000000000000000d10eb37ef5838bb835ea71bbd4053daf8de7bd8e
  eq ASSERT() // []

  // Validate that the total increased to 1
  ADDRESSES_NUM() 0x01 eq ASSERT() // []
}

#define macro SAVE_BYTES32() = takes (3) returns (2) {
  // input stack: [flag, windex, rindex]

  pop            // [windex, rindex]

  dup2           // [rindex, windex, rindex]
  calldataload   // [word, windex, rindex]

  dup1           // [word, word, windex, rindex]

  dup3           // [windex, word, word, windex, rindex]
  mstore         // [word, windex, rindex]

  PULL_BYTES32() BYTES32_STORAGE_POINTER() sstore  // [windex, rindex]

  // Add 32 bytes to both indexes

  0x20 dup1  // [0x20, 0x20, windex, rindex]
  swap3      // [rindex, 0x20, windex, 0x20]
  add        // [rindex + 0x20, 0x20, windex]

  swap2      // [windex, 0x20, rindex + 0x20]
  add        // [windex + 0x20, rindex + 0x20]

  // output stack: [windex + 32, rindex + 32]
}

#[calldata("0xb2d10eb37ef5838bb835ea71bbd4053daf8de7bd8ecdf638451a2bc966a145a899"), value(0x01)]
#define test TEST_SAVE_BYTES32() = {
  0x01 // [rindex]
  0x20 // [windex, rindex]

  0x02 // [flag, windex, rindex]

  SAVE_BYTES32() // [windex, rindex]

  0x40 eq ASSERT()    // []
  0x21 eq ASSERT()    // [rindex]

  // Validate that memory was written correctly

  0x20 mload  // [mem[0x20]] ()
  0xd10eb37ef5838bb835ea71bbd4053daf8de7bd8ecdf638451a2bc966a145a899
  
  eq ASSERT() // []

  // Validate that the written address is correct
  0x01 0x80 shl sload // [addr]
  0xd10eb37ef5838bb835ea71bbd4053daf8de7bd8ecdf638451a2bc966a145a899 eq ASSERT() // []

  // Validate that the total increased to 1
  BYTES32_NUM() 0x01 eq ASSERT() // []
}

// Reads a stored bytes32 using a 2 to 5 bytes pointer index
#define macro READ_BYTES32_STORAGE() = takes (3) returns (2) {
  READ_STORAGE(READ_BYTES32_X_BYTES_FLAG_OFFSET, BYTES32_SMV, shl)
}

#define macro READ_ADDRESS_STORAGE() = takes (3) returns (2) {
  READ_STORAGE(READ_ADDRESS_X_BYTES_FLAG_OFFSET, ADDRESS_SMV, add)
}

#define macro READ_STORAGE(flagOffset, smv, smc) = takes (3) returns (2) {
  // input stack: [flag, windex, rindex]

  <flagOffset> swap1 sub // [size, windex, rindex]

  swap1 // [windex, size, rindex]
  swap2 // [rindex, size, windex]
  swap1 // [size, rindex, windex]

  LOAD_DYNAMIC_SIZE() // [index, nrindex + size, windex]
  <smv> <smc> sload   // [bytes32, nrindex + size, windex]

  dup3                // [windex, bytes32, nrindex + size, windex]
  mstore              // [nrindex + size, windex]

  swap1               // [windex, nrindex + size]

  0x20 add            // [windex + 0x20, nrindex + size]

  // output stack: [windex + 0x20, nrindex + size]
}

#[calldata("0x0201f020c002f1e0040203")]
#define test TEST_READ_BYTES32() = {
  // Save 3 different bytes32 values

  0xfe9716a384ec3b055bb8aae87323a14412cbfceb52c95324dccf071fb3f83855
  0x0201 0x80 shl sstore

  0xcf85e6408b0191a7ed9970e635257854b95aa7b708f485ae667e6fd467e5f45e
  0xf020c002 0x80 shl sstore

  0xa577e893e614c9aa4b19f2369e1c177adab9fe3156970a39afc166c0f2d905ee
  0xf1e0040203 0x80 shl sstore

  // Read the first bytes32
  0x00                        // [rindex]
  0x00                        // [windex, rindex]
  [FLAG_READ_BYTES32_2_BYTES] // [flag, windex, rindex]

  READ_BYTES32_STORAGE() // [windex, rindex]

  0x20 eq ASSERT() // [rindex]
  0x02 eq ASSERT() // []

  0x00 mload 0xfe9716a384ec3b055bb8aae87323a14412cbfceb52c95324dccf071fb3f83855 eq ASSERT() // []

  // Read the second bytes32
  0x02                                 // [rindex]
  0x20                                 // [windex, rindex]
  [FLAG_READ_BYTES32_2_BYTES] 0x02 add // [flag, windex, rindex]

  READ_BYTES32_STORAGE() // [windex, rindex]

  0x40 eq ASSERT() // [rindex]
  0x06 eq ASSERT() // []

  0x20 mload 0xcf85e6408b0191a7ed9970e635257854b95aa7b708f485ae667e6fd467e5f45e eq ASSERT() // []

  // Read the third bytes32
  0x06                                 // [rindex]
  0x10                                 // [windex, rindex]

  [FLAG_READ_BYTES32_2_BYTES] 0x03 add // [flag, windex, rindex]

  READ_BYTES32_STORAGE() // [windex, rindex]

  0x30 eq ASSERT() // [rindex]
  0x0b eq ASSERT() // []

  0x10 mload 0xa577e893e614c9aa4b19f2369e1c177adab9fe3156970a39afc166c0f2d905ee eq ASSERT() // []
}

#[calldata("0x0201f020c002f1e0040203")]
#define test TEST_READ_ADDRESS() = {
  // Save 3 different bytes32 values

  0x000000000000000000000000d789f5242a537b0584893b564a8c7a4be35b9238
  0x0201 ADDRESS_STORAGE_POINTER() sstore

  0x000000000000000000000000d5b5127436fd875ab7c334dffb62533ba011c2d9
  0xf020c002 ADDRESS_STORAGE_POINTER() sstore

  0x0000000000000000000000008a745d2b92c6e02e8ed087581c63d073f98f2479
  0xf1e0040203 ADDRESS_STORAGE_POINTER() sstore

  // Read the first bytes32
  0x00                        // [rindex]
  0x00                        // [windex, rindex]
  [FLAG_READ_ADDRESS_2_BYTES] // [flag, windex, rindex]

  READ_ADDRESS_STORAGE() // [windex, rindex]

  0x20 eq ASSERT() // [rindex]
  0x02 eq ASSERT() // []

  0x00 mload 0x000000000000000000000000d789f5242a537b0584893b564a8c7a4be35b9238 eq ASSERT() // []

  // Read the second bytes32
  0x02                                 // [rindex]
  0x20                                 // [windex, rindex]
  [FLAG_READ_ADDRESS_2_BYTES] 0x02 add // [flag, windex, rindex]

  READ_ADDRESS_STORAGE() // [windex, rindex]

  0x40 eq ASSERT() // [rindex]
  0x06 eq ASSERT() // []

  0x20 mload 0x000000000000000000000000d5b5127436fd875ab7c334dffb62533ba011c2d9 eq ASSERT() // []

  // Read the third bytes32
  0x06                                 // [rindex]
  0x10                                 // [windex, rindex]

  [FLAG_READ_ADDRESS_2_BYTES] 0x03 add // [flag, windex, rindex]

  READ_ADDRESS_STORAGE() // [windex, rindex]

  0x30 eq ASSERT() // [rindex]
  0x0b eq ASSERT() // []

  0x10 mload 0x0000000000000000000000008a745d2b92c6e02e8ed087581c63d073f98f2479 eq ASSERT() // []
}

// TODO: The first 4/5 bits of the exponent are never going to be used
// (ther are literals for those values) it may be worth to use them
// for special cases of power_2 (-1, +1, etc).
#define macro READ_POWER_OF_2() = takes (2) returns (2) {
  // input stack: [windex, rindex]

  0x01          // [0x01, windex, rindex]
  dup3          // [rindex, 0x01, windex, rindex]

  calldataload  // [cdata[rindex], 0x01, windex, rindex]

  0x00 byte     // [cdata[rindex][0:8], 0x01, windex, rindex]

  shl           // [0x01 << cdata[rindex][0:8], windex, rindex]

  dup2          // [windex, 0x01 << cdata[rindex][0:8], windex, rindex]
  mstore        // [windex, rindex]


  0x20 add           // [windex + 0x20, rindex]
  swap1              // [rindex, windex + 0x20]
  0x01 add           // [rindex + 0x01, windex + 0x20]
  swap1              // [windex + 0x20, rindex + 0x01]

  // output stack: [windex + 0x20, rindex + 0x01]
}

#[calldata("0x000203ff")]
#define test TEST_READ_POWER_OF_2() = takes (2) returns (2) {
  0x00 // [rindex]
  0x00 // [windex, rindex]

  READ_POWER_OF_2() // [windex, rindex]

  0x20 eq ASSERT() // [rindex]
  0x01 eq ASSERT() // []

  0x00 mload 0x01 eq ASSERT() // []

  0x01 // [rindex]
  0x20 // [windex, rindex]

  READ_POWER_OF_2() // [windex, rindex]

  0x40 eq ASSERT() // [rindex]
  0x02 eq ASSERT() // []

  0x20 mload 0x04 eq ASSERT() // []

  0x02 // [rindex]
  0x05 // [windex, rindex]

  READ_POWER_OF_2() // [windex, rindex]

  0x25 eq ASSERT() // [rindex]
  0x03 eq ASSERT() // []

  0x05 mload 0x08 eq ASSERT() // []

  0x03 // [rindex]
  0x00 // [windex, rindex]

  READ_POWER_OF_2() // [windex, rindex]

  0x20 eq ASSERT() // [rindex]
  0x04 eq ASSERT() // []

  0x00 mload 0x8000000000000000000000000000000000000000000000000000000000000000 eq ASSERT() // []
}

#define macro READ_MAX_UINT256() = takes (2) returns (2) {
  // input stack: [windex, rindex]

  0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff dup2 mstore
  0x20 add           // [windex + 0x20, rindex]

  // output stack: [windex + 0x20, rindex]
}

#define test TEST_READ_MAX_UINT256() = {
  0x00 // [rindex]
  0x10 // [windex, rindex]

  READ_MAX_UINT256() // [windex, rindex]

  0x30 eq ASSERT() // [rindex]
  0x00 eq ASSERT() // []

  0x10 mload 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff eq ASSERT() // []
}

#define macro READ_N_BYTES(nrfs) = takes (2) returns (2) {
  // input stack: [flag, windex, rindex]

  pop                              // [windex, rindex]

  PERFORM_NESTED_READ_FLAG(<nrfs>) // [windex, rindex]
  BACKREAD_SINGLE_VALUE()          // [size, windex, rindex]

  dup2          // [windex, size, windex, rindex + 1]
  dup2 add      // [windex + size, size, windex, rindex + 1]
  swap2         // [windex, size, windex + size, rindex + 1]

  dup4          // [rindex + 1, windex, size, windex + size, rindex + 1]
  dup3          // [size, rindex + 1, windex, size, windex + size, rindex + 1]
  add           // [rindex + 1 + size, windex, size, windex + size, rindex + 1]
  swap4         // [rindex + 1, windex, size, windex + size, rindex + 1 + size]
  swap1         // [windex, rindex + 1, size, windex + size, rindex + 1 + size]

  calldatacopy  // [windex, rindex + 1 + size]

  // output stack: [windex + size, rindex + size]
}


#define macro LOAD_DYNAMIC_SIZE() = takes (2) returns (2) {
  // input stack: [size, rindex]

  dup2          // [rindex, size, rindex]

  dup2          // [size, rindex, size, rindex]
  add           // [size + rindex, size, rindex]
  swap2         // [rindex, size, size + rindex]

  calldataload  // [cdata[rindex], size, size + rindex]

  // Value needs to be shifted, so we only read
  // the first "size" bytes

  swap1         // [size, cdata[rindex], size + rindex]
  0x08 mul      // [size bits, cdata[rindex], size + rindex]
  0x0100        // [0x0100, size bits, cdata[rindex], size + rindex]
  sub           // [0x0100 - size bits, cdata[rindex], size + rindex]

  shr           // [cdata[rindex] >> size bits, size + rindex]

  // output stack: [cdata[rindex] >> size bits, size + rindex]
}

#[calldata("0xb2d10eb37ef5838bb835ea71bbd4053daf8de7bd8ecdf638451a2bc966a145a899")]
#define test TEST_LOAD_DYNAMIC_SIZE() = {
  0x00 // [rindex]
  0x02 // [size, rindex]

  LOAD_DYNAMIC_SIZE() // [val, nrindex + size]

  0xb2d1 eq ASSERT()    // [rindex]
  0x02 eq ASSERT()      // []

  0x04 // [rindex]
  0x05 // [size, rindex]

  LOAD_DYNAMIC_SIZE() // [val, nrindex + size]

  0x7ef5838bb8 eq ASSERT()    // [rindex]
  0x09 eq ASSERT()            // []
}