#include "./Errors.huff"

#define constant ADDR_BYTES_STORAGE = 0x00
#define constant FREE_MEMORY_START = 0x40

#define constant FLAG_READ_BYTES32_2_BYTES = 0x23
#define constant FLAG_READ_ADDRESS_2_BYTES = 0x27

#define constant READ_BYTES32_X_BYTES_FLAG_OFFSET = 0x21 // (FLAG_READ_BYTES32_2_BYTES - 2) since it starts at 2 bytes
#define constant READ_ADDRESS_X_BYTES_FLAG_OFFSET = 0x25 // (FLAG_READ_ADDRESS_2_BYTES - 2) since it starts at 2 bytes

#define constant BYTES32_SMV = 0x80
#define constant ADDRESS_SMV = 0x01

#define macro MAIN() = takes (0) returns (0) {
  0x00                 // [rindex]
  [FREE_MEMORY_START]  // [windex, rindex]

  0x01                 // [flag, windex, rindex]
  FLAG_READ_BYTES32()    // [windex, rindex]
}

#define macro ADDRESSES_NUM() = takes (0) returns (1) {
  [ADDR_BYTES_STORAGE] sload // [packed]
  0x80 shr                 // [num]

  // output stack: [num]
}

#define macro PULL_ADDRESS() = takes(0) returns (1) {
  [ADDR_BYTES_STORAGE] sload // [packed]
  dup1                       // [packed, packed]
  0x80 shr                   // [num, packed]

  0x01 add                   // [num + 1, packed]
  swap1                      // [packed, num + 1]

  // Mask packed (only want lower 128 bits)
  0xffffffffffffffffffffffffffffffff and

  dup2                       // [num + 1, packed, num + 1]
  0x80 shl                   // [num + 1 << 0x80, packed, num + 1]
  or                         // [nextpacked, num + 1]

  [ADDR_BYTES_STORAGE] sstore // [num + 1]

  // output stack: [num + 1]
}

#define macro BYTES32_STORAGE_POINTER() = takes (1) returns (1) {
  // input stack: [index]
  0x80 shl
  // output stack: [index << 0x80]
}

#define macro ADDRESS_STORAGE_POINTER() = takes (1) returns (1) {
  // input stack: [index]
  0x01 add
  // output stack: [index + 1]
}

#define macro BYTES32_NUM() = takes (0) returns (1) {
  [ADDR_BYTES_STORAGE] sload             // [packed]
  0xffffffffffffffffffffffffffffffff and // [num]

  // output stack: [num]
}

#define macro PULL_BYTES32() = takes(0) returns (1) {
  [ADDR_BYTES_STORAGE] sload             // [packed]
  dup1                                   // [packed, packed]
  0xffffffffffffffffffffffffffffffff and // [num, packed]

  0x01 add                               // [num + 1, packed]
  swap1                                  // [packed, num + 1]

  0xffffffffffffffffffffffffffffffff00000000000000000000000000000000 and // [packed, num + 1]

  dup2                                   // [num + 1, packed, num + 1]
  or                                     // [nextpacked, num + 1]

  [ADDR_BYTES_STORAGE] sstore            // [num + 1]

  // output stack: [num + 1]
}

#define test TEST_NUMS() = {
  ADDRESSES_NUM()  // [num]
  0x00 eq ASSERT() // []

  PULL_ADDRESS()   // [nnum]
  0x01 eq ASSERT() // []

  ADDRESSES_NUM()  // [num]
  0x01 eq ASSERT() // []

  PULL_ADDRESS()   // [nnum]
  0x02 eq ASSERT() // []

  ADDRESSES_NUM()  // [num]
  0x02 eq ASSERT() // []

  PULL_BYTES32()   // [nnum]
  0x01 eq ASSERT() // []

  BYTES32_NUM()    // [num]
  0x01 eq ASSERT() // []

  ADDRESSES_NUM()  // [num]
  0x02 eq ASSERT() // []

  PULL_ADDRESS()   // [nnum]
  0x03 eq ASSERT() // []

  BYTES32_NUM()   // [nnum]
  0x01 eq ASSERT() // []
}

#define macro FLAG_READ_BYTES32() = takes (3) returns (2) {
  // input stack: [flag, windex, rindex, initial]

  0x20       // [0x20, flag, windex, rindex, initial]
  dup4       // [rindex, 0x20, flag, windex, rindex, initial]
  dup4       // [windex, rindex, 0x20, flag, windex, rindex, initial]

  calldatacopy // [flag, windex, rindex, initial]

  // Increment both rindex and windex by the size of the flag

  dup1       // [flag, flag, windex, rindex, initial]
  swap3      // [rindex, flag, windex, flag, initial]

  add        // [rindex + flag, windex, flag, initial]
  swap2      // [flag, windex, rindex + flag, initial]

  add        // [flag + windex, rindex + flag, initial]

  // output stack: [flag + windex, flag + rindex, initial]
}

#[calldata("0xb2d10eb37ef5838bb835ea71bbd4053daf8de7bd8ecdf638451a2bc966a145a8"), value(0x01)]
#define test TEST_FLAG_READ_BYTES32() = {
  0x01 // [rindex]
  0x20 // [windex]

  0x02 // [flag, windex, rindex]

  FLAG_READ_BYTES32() // [windex, rindex]

  0x22 eq ASSERT()    // [rindex]
  0x03 eq ASSERT()    // []

  // Validate that memory was written correctly

  0x20 mload  // [mem[0x20]]
  0xd10eb37ef5838bb835ea71bbd4053daf8de7bd8ecdf638451a2bc966a145a800
  
  eq ASSERT() // []
}

#define macro FLAG_SAVE_ADDRESS() = takes (3) returns (2) {
  // input stack: [flag, windex, rindex]

  pop            // [windex, rindex]

  dup2           // [rindex, windex, rindex]
  calldataload   // [word, windex, rindex]

  dup1           // [word, word, windex, rindex]

  dup3           // [windex, word, word, windex, rindex]
  mstore         // [word, windex, rindex]

  // Clean the address before storing it
  // shifting it to the right by 0x60 bits

  0x60 shr                       // [addr, windex, rindex]
  PULL_ADDRESS() ADDRESS_STORAGE_POINTER() sstore // [windex, rindex]

  // Add 32 bytes to both indexes

  0x20 dup1  // [0x20, 0x20, windex, rindex]
  swap3      // [rindex, 0x20, windex, 0x20]
  add        // [rindex + 0x20, 0x20, windex]

  swap2      // [windex, 0x20, rindex + 0x20]
  add        // [windex + 0x20, rindex + 0x20]

  // output stack: [windex + 20, rindex + 20]
}

// 0xd10eb37ef5838bb835ea71bbd4053daf8de7bd8e
#[calldata("0xb2d10eb37ef5838bb835ea71bbd4053daf8de7bd8ecdf638451a2bc966a145a8"), value(0x01)]
#define test TEST_FLAG_SAVE_ADDRESS() = {
  0x01 // [rindex]
  0x20 // [windex, rindex]

  0x02 // [flag, windex, rindex]

  FLAG_SAVE_ADDRESS() // [windex, rindex]

  0x40 eq ASSERT()    // [rindex]
  0x21 eq ASSERT()    // []

  // Validate that memory was written correctly

  0x20 mload  // [mem[0x20]] ()
  0xd10eb37ef5838bb835ea71bbd4053daf8de7bd8ecdf638451a2bc966a145a800
  
  eq ASSERT() // []

  // Validate that the written address is correct
  0x02 sload // [addr]
  0xd10eb37ef5838bb835ea71bbd4053daf8de7bd8e eq ASSERT() // []

  // Validate that the total increased to 1
  ADDRESSES_NUM() 0x01 eq ASSERT() // []
}

#define macro FLAG_SAVE_BYTES32() = takes (3) returns (2) {
  // input stack: [flag, windex, rindex]

  pop            // [windex, rindex]

  dup2           // [rindex, windex, rindex]
  calldataload   // [word, windex, rindex]

  dup1           // [word, word, windex, rindex]

  dup3           // [windex, word, word, windex, rindex]
  mstore         // [word, windex, rindex]

  PULL_BYTES32() BYTES32_STORAGE_POINTER() sstore  // [windex, rindex]

  // Add 32 bytes to both indexes

  0x20 dup1  // [0x20, 0x20, windex, rindex]
  swap3      // [rindex, 0x20, windex, 0x20]
  add        // [rindex + 0x20, 0x20, windex]

  swap2      // [windex, 0x20, rindex + 0x20]
  add        // [windex + 0x20, rindex + 0x20]

  // output stack: [windex + 32, rindex + 32]
}

#[calldata("0xb2d10eb37ef5838bb835ea71bbd4053daf8de7bd8ecdf638451a2bc966a145a899"), value(0x01)]
#define test TEST_FLAG_SAVE_BYTES32() = {
  0x01 // [rindex]
  0x20 // [windex, rindex]

  0x02 // [flag, windex, rindex]

  FLAG_SAVE_BYTES32() // [windex, rindex]

  0x40 eq ASSERT()    // []
  0x21 eq ASSERT()    // [rindex]

  // Validate that memory was written correctly

  0x20 mload  // [mem[0x20]] ()
  0xd10eb37ef5838bb835ea71bbd4053daf8de7bd8ecdf638451a2bc966a145a899
  
  eq ASSERT() // []

  // Validate that the written address is correct
  0x01 0x80 shl sload // [addr]
  0xd10eb37ef5838bb835ea71bbd4053daf8de7bd8ecdf638451a2bc966a145a899 eq ASSERT() // []

  // Validate that the total increased to 1
  BYTES32_NUM() 0x01 eq ASSERT() // []
}

// Reads a stored bytes32 using a 2 to 5 bytes pointer index
#define macro READ_BYTES32() = takes (3) returns (2) {
  READ_STORAGE(READ_BYTES32_X_BYTES_FLAG_OFFSET, BYTES32_SMV, shl)
}

#define macro READ_ADDRESS() = takes (3) returns (2) {
  READ_STORAGE(READ_ADDRESS_X_BYTES_FLAG_OFFSET, ADDRESS_SMV, add)
}

#define macro READ_STORAGE(flagOffset, smv, smc) = takes (3) returns (2) {
  // input stack: [flag, windex, rindex]

  <flagOffset> swap1 sub // [size, windex, rindex]

  swap1 // [windex, size, rindex]
  swap2 // [rindex, size, windex]
  swap1 // [size, rindex, windex]

  LOAD_DYNAMIC_SIZE()      // [index, nrindex + size, windex]
  <smv> <smc> sload   // [bytes32, nrindex + size, windex]

  dup3                // [windex, bytes32, nrindex + size, windex]
  mstore              // [nrindex + size, windex]

  swap1               // [windex, nrindex + size]

  0x20 add            // [windex + 0x20, nrindex + size]

  // output stack: [windex + 0x20, nrindex + size]
}

#[calldata("0x0201f020c002f1e0040203")]
#define test TEST_READ_BYTES32() = {
  // Save 3 different bytes32 values

  0xfe9716a384ec3b055bb8aae87323a14412cbfceb52c95324dccf071fb3f83855
  0x0201 0x80 shl sstore

  0xcf85e6408b0191a7ed9970e635257854b95aa7b708f485ae667e6fd467e5f45e
  0xf020c002 0x80 shl sstore

  0xa577e893e614c9aa4b19f2369e1c177adab9fe3156970a39afc166c0f2d905ee
  0xf1e0040203 0x80 shl sstore

  // Read the first bytes32
  0x00                        // [rindex]
  0x00                        // [windex, rindex]
  [FLAG_READ_BYTES32_2_BYTES] // [flag, windex, rindex]

  READ_BYTES32() // [windex, rindex]

  0x20 eq ASSERT() // [rindex]
  0x02 eq ASSERT() // []

  0x00 mload 0xfe9716a384ec3b055bb8aae87323a14412cbfceb52c95324dccf071fb3f83855 eq ASSERT() // []

  // Read the second bytes32
  0x02                                 // [rindex]
  0x20                                 // [windex, rindex]
  [FLAG_READ_BYTES32_2_BYTES] 0x02 add // [flag, windex, rindex]

  READ_BYTES32() // [windex, rindex]

  0x40 eq ASSERT() // [rindex]
  0x06 eq ASSERT() // []

  0x20 mload 0xcf85e6408b0191a7ed9970e635257854b95aa7b708f485ae667e6fd467e5f45e eq ASSERT() // []

  // Read the third bytes32
  0x06                                 // [rindex]
  0x10                                 // [windex, rindex]

  [FLAG_READ_BYTES32_2_BYTES] 0x03 add // [flag, windex, rindex]

  READ_BYTES32() // [windex, rindex]

  0x30 eq ASSERT() // [rindex]
  0x0b eq ASSERT() // []

  0x10 mload 0xa577e893e614c9aa4b19f2369e1c177adab9fe3156970a39afc166c0f2d905ee eq ASSERT() // []
}

#[calldata("0x0201f020c002f1e0040203")]
#define test TEST_READ_ADDRESS() = {
  // Save 3 different bytes32 values

  0x000000000000000000000000d789f5242a537b0584893b564a8c7a4be35b9238
  0x0201 ADDRESS_STORAGE_POINTER() sstore

  0x000000000000000000000000d5b5127436fd875ab7c334dffb62533ba011c2d9
  0xf020c002 ADDRESS_STORAGE_POINTER() sstore

  0x0000000000000000000000008a745d2b92c6e02e8ed087581c63d073f98f2479
  0xf1e0040203 ADDRESS_STORAGE_POINTER() sstore

  // Read the first bytes32
  0x00                        // [rindex]
  0x00                        // [windex, rindex]
  [FLAG_READ_ADDRESS_2_BYTES] // [flag, windex, rindex]

  READ_ADDRESS() // [windex, rindex]

  0x20 eq ASSERT() // [rindex]
  0x02 eq ASSERT() // []

  0x00 mload 0x000000000000000000000000d789f5242a537b0584893b564a8c7a4be35b9238 eq ASSERT() // []

  // Read the second bytes32
  0x02                                 // [rindex]
  0x20                                 // [windex, rindex]
  [FLAG_READ_ADDRESS_2_BYTES] 0x02 add // [flag, windex, rindex]

  READ_ADDRESS() // [windex, rindex]

  0x40 eq ASSERT() // [rindex]
  0x06 eq ASSERT() // []

  0x20 mload 0x000000000000000000000000d5b5127436fd875ab7c334dffb62533ba011c2d9 eq ASSERT() // []

  // Read the third bytes32
  0x06                                 // [rindex]
  0x10                                 // [windex, rindex]

  [FLAG_READ_ADDRESS_2_BYTES] 0x03 add // [flag, windex, rindex]

  READ_ADDRESS() // [windex, rindex]

  0x30 eq ASSERT() // [rindex]
  0x0b eq ASSERT() // []

  0x10 mload 0x0000000000000000000000008a745d2b92c6e02e8ed087581c63d073f98f2479 eq ASSERT() // []
}

// TODO: The first 4/5 bits of the exponent are never going to be used
// (ther are literals for those values) it may be worth to use them
// for special cases of power_2 (-1, +1, etc).
#define macro READ_POWER_OF_2() = takes (2) returns (2) {
  // input stack: [windex, rindex]

  0x01          // [0x01, windex, rindex]
  dup3          // [rindex, 0x01, windex, rindex]

  calldataload  // [cdata[rindex], 0x01, windex, rindex]

  0x00 byte     // [cdata[rindex][0:8], 0x01, windex, rindex]

  shl           // [0x01 << cdata[rindex][0:8], windex, rindex]

  dup2          // [windex, 0x01 << cdata[rindex][0:8], windex, rindex]
  mstore        // [windex, rindex]


  0x20 add           // [windex + 0x20, rindex]
  swap1              // [rindex, windex + 0x20]
  0x01 add           // [rindex + 0x01, windex + 0x20]
  swap1              // [windex + 0x20, rindex + 0x01]

  // output stack: [windex + 0x20, rindex + 0x01]
}

#[calldata("0x000203ff")]
#define test TEST_READ_POWER_OF_2() = takes (2) returns (2) {
  0x00 // [rindex]
  0x00 // [windex, rindex]

  READ_POWER_OF_2() // [windex, rindex]

  0x20 eq ASSERT() // [rindex]
  0x01 eq ASSERT() // []

  0x00 mload 0x01 eq ASSERT() // []

  0x01 // [rindex]
  0x20 // [windex, rindex]

  READ_POWER_OF_2() // [windex, rindex]

  0x40 eq ASSERT() // [rindex]
  0x02 eq ASSERT() // []

  0x20 mload 0x04 eq ASSERT() // []

  0x02 // [rindex]
  0x05 // [windex, rindex]

  READ_POWER_OF_2() // [windex, rindex]

  0x25 eq ASSERT() // [rindex]
  0x03 eq ASSERT() // []

  0x05 mload 0x08 eq ASSERT() // []

  0x03 // [rindex]
  0x00 // [windex, rindex]

  READ_POWER_OF_2() // [windex, rindex]

  0x20 eq ASSERT() // [rindex]
  0x04 eq ASSERT() // []

  0x00 mload 0x8000000000000000000000000000000000000000000000000000000000000000 eq ASSERT() // []
}

#define macro READ_MAX_UINT256() = takes (2) returns (2) {
  // input stack: [windex, rindex]

  0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff dup2 mstore
  0x20 add           // [windex + 0x20, rindex]

  // output stack: [windex + 0x20, rindex]
}

#define test TEST_READ_MAX_UINT256() = {
  0x00 // [rindex]
  0x10 // [windex, rindex]

  READ_MAX_UINT256() // [windex, rindex]

  0x30 eq ASSERT() // [rindex]
  0x00 eq ASSERT() // []

  0x10 mload 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff eq ASSERT() // []
}

#define macro READ_N_BYTES() = takes (2) returns (2) {
  // input stack: [windex, rindex]

  dup2          // [rindex, windex, rindex]
  calldataload  // [cdata[rindex], windex, rindex]

  0x00 byte     // [size, windex, rindex]

  swap2         // [rindex, windex, size]
  0x01 add      // [rindex + 1, windex, size]
  swap2         // [size, windex, rindex + 1]

  dup2          // [windex, size, windex, rindex + 1]
  dup2 add      // [windex + size, size, windex, rindex + 1]
  swap2         // [windex, size, windex + size, rindex + 1]

  dup4          // [rindex + 1, windex, size, windex + size, rindex + 1]
  dup3          // [size, rindex + 1, windex, size, windex + size, rindex + 1]
  add           // [rindex + 1 + size, windex, size, windex + size, rindex + 1]
  swap4         // [rindex + 1, windex, size, windex + size, rindex + 1 + size]
  swap1         // [windex, rindex + 1, size, windex + size, rindex + 1 + size]

  calldatacopy  // [windex, rindex + 1 + size]

  // output stack: [windex + size, rindex + 1 + size]
}

#[calldata("0x02f1f240a3b3dcc26b3a2b584cf0427ac8ef901401c89b22613407ddfc6790209bf4151a2ed3d1275d5f8f13a8cbe8adda0193aaf438230c921b2d717dc314592b9f53fc")]
#define test TEST_READ_N_BYTES() = {
  0x00 // [rindex]
  0x00 // [windex, rindex]

  READ_N_BYTES() // [windex, rindex]

  0x02 eq ASSERT() // [rindex]
  0x03 eq ASSERT() // []

  0x00 mload 0x00 byte 0xf1 eq ASSERT() // []
  0x00 mload 0x01 byte 0xf2 eq ASSERT() // []

  0x03 // [rindex]
  0x20 // [windex, rindex]

  READ_N_BYTES() // [windex, rindex]

  0x60 eq ASSERT() // [rindex]
  0x03 0x40 add 0x01 add eq ASSERT() // []

  0x20 mload 0xa3b3dcc26b3a2b584cf0427ac8ef901401c89b22613407ddfc6790209bf4151a eq ASSERT() // []
  0x40 mload 0x2ed3d1275d5f8f13a8cbe8adda0193aaf438230c921b2d717dc314592b9f53fc eq ASSERT() // []
}

#define macro LOAD_DYNAMIC_SIZE() = takes (2) returns (2) {
  // input stack: [size, rindex]

  dup2          // [rindex, size, rindex]

  dup2          // [size, rindex, size, rindex]
  add           // [size + rindex, size, rindex]
  swap2         // [rindex, size, size + rindex]

  calldataload  // [cdata[rindex], size, size + rindex]

  // Value needs to be shifted, so we only read
  // the first "size" bytes

  swap1         // [size, cdata[rindex], size + rindex]
  0x08 mul      // [size bits, cdata[rindex], size + rindex]
  0x0100        // [0x0100, size bits, cdata[rindex], size + rindex]
  sub           // [0x0100 - size bits, cdata[rindex], size + rindex]

  shr           // [cdata[rindex] >> size bits, size + rindex]

  // output stack: [cdata[rindex] >> size bits, size + rindex]
}

#[calldata("0xb2d10eb37ef5838bb835ea71bbd4053daf8de7bd8ecdf638451a2bc966a145a899")]
#define test TEST_LOAD_DYNAMIC_SIZE() = {
  0x00 // [rindex]
  0x02 // [size, rindex]

  LOAD_DYNAMIC_SIZE() // [val, nrindex + size]

  0xb2d1 eq ASSERT()    // [rindex]
  0x02 eq ASSERT()      // []

  0x04 // [rindex]
  0x05 // [size, rindex]

  LOAD_DYNAMIC_SIZE() // [val, nrindex + size]

  0x7ef5838bb8 eq ASSERT()    // [rindex]
  0x09 eq ASSERT()            // []
}